[["index.html", "Sozialwissenschaftliche Datenanalyse mit R Einführung", " Sozialwissenschaftliche Datenanalyse mit R Kenneth Horvath &amp; Guy Schwegler HS 2021 Einführung Das Seminar Sozialwissenschaftliche Datenanalyse mit R bietet eine systematische Einführung in das Statistikpaket R sowie die Benutzeroberfläche RStudio. R ist eine Open Source Software, die sich unter anderem durch Flexibilität sowie durch vielfältige Möglichkeiten der numerischen und grafischen Datenanalyse auszeichnet. Das Seminar führt auf der einen Seite allgemein in den Aufbau des Programms und dessen Funktionsweisen ein. Auf der anderen Seite werden gewisse statistische Verfahren auch in inhaltliche Abstimmung mit der Vorlesung Grundlagen der multivariaten Statistik vermittelt. Anhand der Funktionsweisen und der Verfahren werden dann Techniken des effizienten Datenmanagements, Möglichkeiten zur eigenständigen Programmierung von kleinen Funktionen sowie Formen der grafischen Datenanalyse und Ergebnisdarstellung besprochen. Das vorliegende Dokument ist ein sogenanntes Bookdown (Xie 2020), siehe auch hier, und dient der Ergebnissicherung im Seminarverlauf. Das heisst dass die im Seminar besprochene Themen hiernochmals schriftlich festgehalten, diskutiert und allenfalls mit Literatur ergänzt werden (siehe für allgemeine Literatur etwa Diaz-Bone (2019), Kabacoff (2015) oder Manderscheid (2017)). Das Bookdown wird laufend aktualisiert. Ebenfalls werden in diesem Bookdown die Lösungen für die im Seminar beziehungsweise in den Wochenplänen gestellten Aufgaben präsentiert (Falllösungen). References "],["wocheplan-01.html", "1 Wocheplan 01 1.1 Sozialwissenschaftliche Datenanalyse 1.2 Ziel des Kurses 1.3 R als Programm &amp; RStudio 1.4 Lernziele der ersten Woche 1.5 Aufgaben der ersten Woche 1.6 Ergänzung: Standardabweichung zwischen Grundgesamtheit und Stichprobe", " 1 Wocheplan 01 Vorbereitung von der 01. auf die 02.Einheit. 1.1 Sozialwissenschaftliche Datenanalyse Das Seminar sozialwissenschaftliche Datenanalyse mit R versucht eine Realität des statistischen Arbeitens zu vermitteln und ergänzt so die Vorlesung Grundlagen der multivariaten Statistik gleich in zweierlei Hinsicht: Erstens wird eine Auswahl der gelernten statistischen Verfahren konkret angewendet (und so auch nochmals repetiert). Zweitens zeigt sich neben den eigentlichen Verfahren ein weiterer, impliziter Teil der Statistik: ein Umgang mit Daten, deren Aufbereitung und Verarbeitung sowie die damit einhergehenden Herausforderungen. Hinter dem Seminar steht eine bestimmte Vorstellung der sozialwissenschaftlichen Datenanalyse, die folgende Teile enthält (Wickham and Grolemund 2016): Figure 1.1: Modell Datenanalyse Als erster Schritt müssen die Daten eingelesen bzw. importiert werden. Die importierten Daten gilt es dann aufzubereiten und aufzuräumen. Das bedeutet, dass sie in einer konsistenten Form gespeichert werden sollen (z.Bsp. dass jede Zeile einer Person und jede Spalte einer Variable entspricht). Dieser zweite Schritt ist im Rahmen von Sekundärdaten (wie auch wir sie verwenden werden) oft bereits erfolgt. Ein weiterer Schritt ist es dann, die Daten zu transformieren. Das heisst die Fälle und ihre Ausprägungen werden auf ein bestimmes Interesse eingegrenzt (z.Bsp. auf alle Personen die über ein bestimmtes Einkommen verfügen), neue Variablen werden erstellt (die Funktionen bestehender Variablen sind, etwa Einkommensklassen), und eine Reihe von zusammenfassenden Statistiken werden berechnet (verschiedene univariate Kennwerte). Das Aufbereiten und Transformieren ist ein grosser Teil der statistischen Analyse (es ist ein Kampf mit den Daten, Wickham and Grolemund 2016, Kap.1.1). Ziel dieser Arbeit ist es, die Daten in eine passende Form zu bringen, um optimal mit ihnen arbeiten zu können. Wenn die Daten (voerst) in einer optimalen Form vorliegen gibt es zwei Hauptmotoren der Wissensgenerierung (Wickham and Grolemund 2016, Kap.1.1): Visualisierung und Modellierung. Mit Visualisierungen lässt sich schnell eine Übersicht gewinnen (z.Bsp. könnte es überhaupt einen Zusammenhang zwischen zwei Variablen geben?). Modellierungen wiederum ergänzen diese ersten Einsichten, indem präzise Antworten auf Fragen möglich sind (wie gross ist der Zusammenhang genau?). Das Transformieren, Visualisieren und Modellieren der Daten ist dabei keineswegs ein linearer Prozess, sondern es ergeben sich in ihm immer wieder Wechselwirkungen, Rückbezüge und dadurch neue Wege, um an die Daten heranzutreten. Der letzte Schritt der Datenanalyse ist die Kommunikation. Es gilt also sowohl das Vorgehen (zumindest teilweise) als inbesondere auch die Ergebnisse der Analyse anderen mitzuteilen. Diese Prozesse der Datenanalyse finden alle in einem bestimmen Rahmen statt (vgl. auch Sauer 2019, 3). Dies ist auf der einen Seite die Idees des Programmierens im Vorgehen selber (vgl. Wickham and Grolemund 2016, Kap.1.1). Auf der anderen Seite bilden aber die Sozialwissenschaften selber auch einen Rahmen, anhand dessen etwa Datenstrukturen (z.Bsp. dass eine Person ein Fall und damit eine Zeile ist) oder angemessene Ziele der Analyse (ab wann ist ein Zusammenhang etwa gross?) vorgegeben werden. 1.2 Ziel des Kurses Das Seminar verfolgt zwei miteinander verzahnte, übergeordnete Lernziele. Einerseits sollen die Studierenden sich Grundkenntnisse der statistischen Datenanalyse mit R aneignen. Andererseits werden ausgewählte Inhalte der Vorlesung praktisch angewandt und damit auch veranschaulicht.1 Konkret sollen die Studierenden am Ende des Semesters einen ersten Einblick in Abläufe und Anforderungen softwaregestützter Datenanalyse haben, typische Herausforderungen statistischen Arbeitens eigenständig bewältigen können, die allgemeine Funktionsweise und die Struktur von R verstehen, die Umsetzung ausgewählter multivariater Verfahren in R beherrschen, dabei auch grafische Verfahren als zentrale Bausteine aktueller Datenanalyse einsetzen können sowie die Grundlage dafür erworben haben, flexibel eigene Analysestrategien in R umzusetzen. 1.3 R als Programm &amp; RStudio R als Programmiersprache wurde von Beginn an für die Statistik beziehungsweise für die Statistiklehre entwickelt. Die Anfänge des Programms fanden in den 1990er Jahre an der Universität Auckland in Neuseeland statt, wo R von Ross Ihaka und Robert Gentleman entwickelt wurde (Manderscheid 2017, 1). Der Buchstabe R als Name geht sowohl auf eine ältere Grundlage zurück  die Programmiersprache S  als auch auf die Vornamen der beiden Entwickler (ebd., vgl. auch Sauer 2019, 13f). Das R-Projekt wurde in der Zusammenareit mit weiteren Wissenschaftler_Innen voran getrieben und bald auch unter der General Public Licence (GNU) veröffentlicht (Manderscheid 2017, 1). R ist daher frei zugänglich, kostenlos und darf von allen verändert werden. Es ist insbesondere auch diese Open Source Idee, die R zu seiner Verbreitung half  und die sicherstellt, dass die neusten Entwicklungen in und mit der Software stattfinden. R als Programm ist in Paketen organisiert und präsentiert sich als Statistikumgebung (Manderscheid 2017, 1). Ausgehend von der Basisversion bzw. des Basispaketes kann R beliebig erweitert werden. Unter https://cran.r-project.org/ findet sich eine beständig wachsende und umfangreiche Sammlung von Paketen, die sowohl Lösungen für allgemeine Verfahren anbieten (etwa Pakete für die multiple Korrespondenzanalyse, siehe soc.ca) als auch für spezifische Probleme (etwa für Atomic Force Microscope Image Analysis beim Paket AFM). Diese Pakete können installiert werden und es gilt sie dann jeweils noch zu laden, bevor sie verwendet werden können. Nach dem Beenden des Programms werden die verwendeten Pakete wieder versorgt und es gilt sie beim nächsten Mal erneut zu laden (die Pakete beleiben aber installiert). Letzterer Vorgang stellt sicher, dass R schlank bleibt, d.h. nur immer die benötigen Dinge auch ausgeführt werden. install.packages(&quot;soc.ca&quot;) #...installiert das Paket library(soc.ca) #...lädt das Paket Neben dieser Open Source Idee und der daraus folgenden, beständigen Aktualisierung und Erweiterungen des Programms zeichnet R sich weiter durch dessen Stärke im Bereich der Visualisierung aus. Es bieten sich unbegrenzte Möglichkeiten für Grafiken und Diagramme, sowohl bereits in der Basisversion als insbesondere auch mit spezifischen Paketen (siehe Chang et al. 2020). Neben der Basisversion von R und R als eigentlicher Programmiersprache gibt es grafische Benutzeroberflächen (GUIs), um mit der Programmiersprache umzugehen. Im Zentrum unseres Seminars steht RStudio, die am weitesten verbreitete grafische Benutzeroberfläche von R. Diese Oberfläche bietet einige praktische Zusatzfunktionen und erleichtert so das Arbeiten mit R durch Autovervollständigkeitsfunktionen, automatische Einrückungen, Syntaxhervorhebung, integrierte Hilfsfunktion, Informationen zu Objekten im Workspace, menügestützten Oberflächen und Daten-Viewer (Manderscheid 2017, 18). Die eigentliche Arbeit verrichtet aber weiterhin R selber, und R wird automatisch gestartet wird, wenn Sie RStudio starten (Sauer 2019, 21). Man kann diese Arbeitsteilung mit einem Auto vergleichen: R ist der Motor des Autos, während RStudio das Amaturenbrett ist, vor dem Sie sitzen und das Auto lenken. 1.4 Lernziele der ersten Woche Die erste Seminarwoche dient dazu, die technischen Voraussetzungen für die gemeinsame Arbeit im Seminar zu prüfen und mit der geplanten Arbeitsweise vertraut zu werden. Das Seminar zielt nicht nur auf einen Frontalunterricht ab, sondern ist als eine Art flipped classroom konzipiert. Sie bekommen also von Woche zu Woche konkrete Arbeitsaufträge (die Falllösungen). Diese sollen Sie eigenständig bewältigen und alle Probleme und Unklarheiten notieren, die sich im Arbeitsprozess ergeben. Die gemeinsamen Sitzungen dienen dann dazu, Lösungswege zu den Aufgaben zu präsentieren, offene Fragen zu klären, Konzepte vertiefend zu erläutern und die nächsten Schritte vorzubereiten. Für jede Woche werden Lernziele und Arbeitsaufträge definiert. Für die erste Seminarwoche lassen sich als Lernziele festhalten: Sie wissen, wie Sie die aktuellen Versionen von R und RStudio auf Ihrem Computer installieren Sie wissen, wie man R-Pakete installiert und in R lädt Sie können eine Funktion aufrufen Sie haben einen soliden ersten Eindruck, wie man mit R kommuniziert und einfache Operationen durchführt Sie haben eine erste Orientierung zu Unterstützungsangeboten, die man online findet (auch wenn diese teilweise noch überfordernd wirken) 1.5 Aufgaben der ersten Woche Installieren Sie die aktuellen Versionen von R und RStudio auf Ihrem Endgerät! Sie sollten sich Notizen machen, wenn es Probleme gibt  und für das nächste Mal gleich festhalten, wie Sie diese gelöst haben. Da die Details der Installation vom Betriebssystem und den Spezifikationen des Endgeräts abhängen, ist es normal, dass dieser Prozess manchmal erst auf den zweiten Versuch funktioniert. Mittels der Funktion version (ACHTUNG: ohne Klammern) lässt sich die Version von R abrufen. Ob dies der aktuellsten Version von R entspricht lässt sich auf der R Projektseite überprüfen. RStudio lässt sich über die Menüsteuerung updaten: Help &gt; Check for Updates. Wichtig: RStudio als grafische Benutzeroberfläche ist nicht dasselbe wie R. Ein Update von RStudio ist also nicht nicht gleich ein Update von R, sondern letzteres muss manuell erfolgen. Das Paket installr und dessen Funktion updateR() ermöglicht auf Windows dass sowohl R als auch die installierten Pakete geupdated werden. Ebenfalls bietet RStudio über die Menüsteuerung eine Möglichkeit, die Pakete zu installieren (Tools&gt;Check for Packages Updates). Zwei Unklarheiten, die aufgetaucht sind: Es sind mehrere Versionen von R auf meinen Computer installiert Ist das ein Problem? Nein, denn RStudio arbeitet automatisch mit der neusten Version. Aber es können auch ältere Versionen verwendet beziehungsweise zwischen den Versionen gewählt werden (siehe Tools &gt; Global Options &gt; General &gt; R Version). Was passiert mit meinen installierten Paketen? Die installierten Pakete bleiben grundsätzlich erhalten. Mittels der Funktion .libPaths() sehen Sie auch, wo diese installiert sind.2 Weiter ist der Umgang mit Paketen kein wirkliches Problem. Da Sie jeweils in Ihrem Code auch spezifizieren, welche Pakete Sie installieren und laden, würde Ihnen ein Fehler sofort auffallen. Dies kann zum Beispiel wiefolgt gemacht werden als Kode in einem Markdown: #install.packages(&quot;swirl&quot;) library(swirl) swirl() #install.packages(&quot;soc.ca&quot;) library(soc.ca) soc.mca(Datenset) Der install.packages()-Befehl ergibt eine Fehlermeldung beim sogenannten knitten, wenn dieser nicht als Kommentar formatiert ist. Der Fehler verweist darauf, dass R kein Repository via Markdown automatisch aufrufen kann. Zwei Möglichkeiten von Josias Bruderer, dies trotzdem zu umgehen (und den install.packages()-Befehl nicht einfach als Kommentar zu setzen): Eine Möglichkeit den Fehlerbefehl auszuschalten ist es, ein Repository anzugeben: install.packages(&quot;swirl&quot;, repos = &quot;https://cran.rstudio.com/&quot;) Eine andere und erweiterte Möglichkeit ist einen Befehl zu ergänzen, der jeweils nur dann ein Paket installiert, wenn dieses benötigt und noch nicht installiert ist: if (!require(&quot;swirl&quot;)) install.packages(&quot;swirl&quot;)   Installieren Sie das Paket swirl und laden Sie es. swirl ist eine in R implementierte interaktive Einführung in die Grundlagen von R! Hier ein Tipp von Julien Lattmann: Sollte dies nach dem Update von R und RStudio womöglich nicht funktioniert haben, dann lohnt es sich nochmals alles zu schliessen, ein paar Moment zu warten und dann nochmals neu zu probieren.   Rufen Sie die Funktion swirl() auf und spielen Sie ein wenig damit. Rufen Sie sich in Erinnerung, was Sie aus dem letzten Semester noch über die Arbeit mit R wissen! Notieren Sie sich, was Ihnen Sie noch kennen, was Ihnen neu vorkommt, und so weiter. Grundsätzlich ging es in dieser Teilaufgabe darum, einige Aspekte von R (erneut) kennenzulernen. Zwei zusammenhängende Dinge sollen hervorgehoben werden: Erwähnt wurde, dass das Programmieren verlangt, sehr genau zu schreiben und kleinste Ungenauigkeiten zu Fehlern führen (etwa ein fehlendes \"). Hier bietet RStudio eine Hilfe an, in dem der Kode farbig gekennzeichnet wird. Diese Hilfe war jedoch um Umgang mit swirl noch nicht ersichtlich, da im Paket direkt in der R Konsole gearbeitet wird. Dies führt zum zweiten Aspekt: Dieser Fokus auf die Konsole beim Paket swirl() ist eher die Ausnahm - und der Hauptteil des Kondierens erfolgt eigentlich immer im einem Skript beziehungsweise in einem Markdown-Dokument (siehe WP02).   Verwenden Sie ein wenig Zeit darauf, online nach R Tutorials, Foren, etc. zu suchen. Halten Sie die URLs von Seiten und Ressourcen fest, die Ihnen hilfreich und/oder wichtig vorkommen (aber unter Umständen noch etwas schwer zu durchschauen) ! Einige Hilfseiten aus Ihren Falllösungen: r-statistics.co: Einführung zu spezifischen Verfahren R Tutorial: viele kurze einführende Beiträge zu Aspekten von R. R Statistik Tutorial: Deutsche Beiträg zu einzelnen Verfahren. RStudio Community: Forum für RStudio R lernen: einige einführende Beiträge auf Deutsch R Forum: deutschsprachiges Forum zu R Einführung in R: ein weiteres, deutsches Bookdown als Einführung in R The R Graph Gallery: für fortgeschrittene Grafiken, insbesondere mit ggplot2 stack overflow: jede Menge Hilfe für alles um R (und Programmieren allgemein) github: eine andere Plattform  aber wiederum: jede Menge Hilfe für alles um R (und Programmieren allgemein) datacamp: kostenpflichte Tutorials für R 1.6 Ergänzung: Standardabweichung zwischen Grundgesamtheit und Stichprobe In der Einheit haben wir gesehen, dass sich eine von R berechnet Standardabweichung leicht von einer selbst berechneten Variante unterscheidet: y &lt;- c(2, 3, 4, 7, 8, 9) sd(y) ## [1] 2.880972 sqrt( sum((y - mean(y))^2) / (length(y)) ) ## [1] 2.629956 In der Hilfeseite der Funktion finden wir den Hinweis darauf, dass mit sd() ähnlich wie mit var() der sogennante unbiased estimator berechnet wird, der von n - 1 ausgeht. help(sd) Like var this uses denominator n - 1. [] The denominator n - 1 is used which gives an unbiased estimator of the (co)variance for i.i.d. observations. Die Standardabweichung wird berechnet, als würde man den Schätzwert für einer Grundgesamtheit aus einer Stichprobe berechnet (i.i.d = Independent and identically distributed random variables). Dies entspricht einer sogenannten Punkteschätzung (Diaz-Bone 2019, 155f): Bei der Punktschätzung errechnet man aus der Stichprobe einen Stichprobenkennwert und schätzt damit die entsprechende Maßzahl in der Grundgesamtheit. Der Stichprobenkennwert, mit dem die Schätzung erfolgt, heißt auch Schätzer. [] Die Standardabweichung eines metrischen Merkmals in der Stichprobe s ist dagegen keine erwartungstreue Schätzung für die Standardabweichung des metrischen Merkmals in der Grundgesamtheit. Aus einer Stichprobe kannman aber mit folgender Formel erwartungstreu schätzen: \\({\\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2}}\\) Dabei wird n - 1 verwendet, da bei kleineren Stichprobenumfängen die Standardabweichung überschätzt wird. Bei grösseren Stichprobenumfängen wird dies dann immer weniger wichtig: z &lt;- rnorm(1000) #eine standardnormalverteilte Varialbe mit n = 50 sd(z) ## [1] 1.028441 sqrt( sum((z - mean(z))^2) / (length(z)) ) ## [1] 1.027927 References "],["wochenplan-02.html", "2 Wochenplan 02 2.1 Lernziele 2.2 Aufgaben", " 2 Wochenplan 02 Vorbereitung von der 02. auf die 03.Einheit. 2.1 Lernziele In der zweiten Seminarwoche geht es darum, die Grundlagen von R und RStudio zu repetieren und zu erweitern.3 Für den weiteren Verlauf wollen wir R als Sprache auffassen  sowohl als Programmiersprache als auch als Sprache in einem metaphorischen Sinn. Wir wollen also ein komplexes System zur Kommunikation kennenlernen. Wie bei einer anderen Sprache gibt es auch hier Zeichen mit Bedeutungen (ähnliche wie Nomen, Verben, . . . ) und Regeln zur Verknüpfung dieser Zeichen (ähnlich wie eine Grammatik). Diese Grundlagen gilt es alle erstmal kennenzulernen und zu verstehen. Am Anfang wird vieles schwer fallen, mit der Zeit gewinnt man aber Sicherheit. Der zentrale Punkt in dieser Vorstellung von R als Sprache ist dabei folgender: Wir lernen eine Sprache dadurch, dass wir sie immer wieder anwenden, Probleme lösen und vor allem auch Fehler machen. R als Software und als Programmiersprache hat eine steile Lernkurve und zu Beginn werden viele Probleme auftauchen. Im Umgang mit den Problemen soll allerdings auch eine eigene Arbeitsweise mit dem Programm erlernt werden (Fehlermeldungen lesen, Lösungsstrategien im Codieren erlernen, selber Hilfe suchen, . . . ). Für die beständige Erweiterung der Grundlagen und das Erlernen der Sprache R besteht eine Herausforderung darin, den Weg zwischen scheinbarer Trivialität und überfordernder Komplexität zu finden: Es gilt die kleinen Schritte ernstzunehmen, sonst werden die grossen Schritte sehr schnell mühsam. Für die zweite Seminarwoche lassen sich folgende Seminarziele festhalten: Sie können die verschiedenen Funktionsweisen der vier Fenster in RStudio erläutern. Sie verstehen den Unterschied zwischen der Arbeit in der Konsole und im Skript. Sie verstehen, wie und wozu man im Skript kommentiert. Sie haben R-Markdown als erweitertes Skript und Arbeitsinstrument kennengelernt. Sie wissen, was ein Arbeitsverzeichnis in R ist und wozu es gut ist. Sie verstehen das erste Grundelement der Sprache R: Funktionen Sie wissen, wie Funktionen aufgebaut sind Sie wissen, wie Sie sich Hilfe zu Funktionen holen; Sie wissen, was Argumente in einer Funktion bewirken. Sie verstehen das zweite Grundelement der Sprache R: Objekte Sie verstehen, was es bedeutet, dass in R alles ein Objekt ist; Sie wissen, wie man sich die jeweils aktuell verfügbare Objekte anzeigen lässt; Sie haben das Zusammenspiel von Funktionen und Objekte kennengelernt; Sie kennen bereits drei verschiedenen Arten von Objekten. 2.2 Aufgaben Fassen Sie noch einmal für sich und in eigenen Worten die Funktionen der vier Fenster von RStudio zusammen. Oben links findet sich in R-Studio das Skript-Fenster, in dem Befehle eingegeben und kommentiert werden können. Ausgeführt werden diese Befehle erst, wenn Sie Ctrl und Enter drücken (bzw. Cmd &amp; Enter). Diese Eingabe von Kodezeilen wird ergänzt durch die direkte Eingabe in der Konsole. In diesem Fenster läuft das eigentliche Programm R (es ist also dieselbe Ansicht wie wenn Sie R ohne grafische Benutzeroberfläche starten würden).4 Im Gegensatz zum Skript können hier Befehle nur immer einzeln eingegeben und sie müssen dann direkt ausgeführt werden. Dies ermöglicht ein schneller ausprobieren, aber eben kein wirklich speichern, beständiges überarbeiten, kommentieren und eine klare Dokumentation des Ablaufs, wie dies im Skript erfolgen kann. Die beiden Fenster zur Eingabe von Kode werden vom Environment-Fenster ergänzt. Hier finden sich die abgespeicherten Objekte sowie in den weiteren Reitern die bisher ausgeführten Befehle (History), aber auch eine erweitere Netzwerk- bzw. Serverumgebung (Connections, Build, ), falls Sie z.Bsp. mit weiteren Personen an einem Projekt arbeiten. Im vierten Fenster werden Grafiken, Hilfeseiten, die Vorschau für geknittete Dokumente und auch die Ordnerstruktur angezeigt. Sie finden diverse Einstellungsoptionen zu den vier Fenster und deren Anordnung unter Tools &gt; Gobal Options. Dort können Sie etwa unter dem Reiter General die Option zum Save Workspace to RData on exit zu Never wechseln. Dies führt dazu, dass Ihre Environment beim Verlassen von R immer gelöscht wird. Dies ist nicht etwa ein Nachteil, sondern eine Technik die Sie dazu veranlasst, alle benötigen Schritte in Ihrem Kode unterzubringen. Weiter könne Sie unter dem Reiter Spelling auch noch die Rechtschreibefunktion deaktiveren, da das Feature noch nicht wirklich für die deutsche Rechtschreibung zu funktionieren scheint (bzw. die Ergänzung von neuen Wörterbüchern nicht fehlerfrei abläuft). Die Ordnerstruktur im Reiter Files des vierten Fensters hängt mit Ihrem aktuellen Arbeitsverzeichnis zusammen. Ein Arbeitsverzeichnis ist der Ort, auf den R immer als Erstes zugreift und wo Dinge automatisch abgelegt werden. Dieses können über die Menüsteuerung Session &gt; Set Working Directory &gt; Choose Directory oder über den Befehl setwd() definieren (erstere Variante ist etwas einfacher). Der getwd() Befehl wiederum gibt das aktuell festgelegte Verzeichnis aus. Speichern Sie jeweils Ihr aktuelles Arbeitsverzeichnis als Teil des Markdowns, z.Bsp. so: setwd(&quot;C:/Users/SchweglG/R_Daten/HS20/E3&quot;) #Dies dient in einem Skript oder einem Markdown als Erinnerung, ... #...wo Ihr Arbeitsverzeichnis liegt (und damit wo Sie Ihre Daten wiederfinden)   Was ist der Vorteil der Arbeit im Skript gegenüber dem Schreiben von Code direkt in der Konsole? Und was könnten dann die Vorteile davon sein, mit R Markdown zu arbeiten? Und wann könnten Sie trotzdem besser mit einem klassischen Skript arbeiten? Schauen Sie sich auch die Formatierungsmöglichkeiten für Fliesstext in den Cheatsheets zu R Markdown an (siehe hier)! Vorteile der Arbeit im Skript: Da Kodezeilen nicht sofort ausgeführt werden müssen ermöglicht das Skript die Strukturierung und Abspeicherung von Befehlen (Delia Bazzigher). Ein weiterer Vorteil kann es sein, komplexe Funktion, die man z.B. in einem RMarkdown braucht, in einem Skript zu hinterlegen, um im RMarkdown nicht zu viel Code einzubauen, damit sich die Leser:innen nicht darum kümmern müssen (Fabio Keller). Vorteile der Arbeit in RMarkdown: RMarkdown bietet die Möglichkeit, Kodezeilen (die Chunk) auf vielfältige Weise mit Text zu ergänzen und diesen Text zu formatieren: bspw. Bold, Italics, Aufzählungszeichen, Übertitel in unterschiedlichen Grössen, etc. []. Auch zwingt es den User, genau zu arbeiten, da [ein RMarkdown] geschlossen funktioniert (bspw. ein Objekt kann sich im Environment befinden, aber nicht im Universum des Markdowns) (Valentina Meyer). Vorteile der Konsole: In der Konsole kann über die beiden Pfeiltasten runter und rauf durch bisher ausgeführte Befehle gescrollt werden. So können Sie die Rechnung erneut aufrufen und dem Objekt x zuweisen. Ebenfalls können in der Konsole Dinge ausprobiert oder Hilfefunktionen aufgerufen werden.   Öffnen Sie eine neue R Markdown Datei. Versuchen Sie Ihre bisherigen Notizen zu den Aufgaben und Ihren Code in dieser Datei unterzubringen (falls Sie dies nicht schon gemacht haben). Arbeiten Sie für die folgenden Aufgaben mit dieser Datei weiter.   Versuchen Sie allgemein zu beschreiben, was Funktionen und was Objekte sind. Fügen Sie eine kurze Erläuterung in Ihr Markdown-Dokument zur Frage ein, was im folgenden Code jeweils Funktionen und was Objekte (und wenn letzteres, welche Art von Objekt) sind: sqrt(x) Funktion(en): sqrt() Objekt(e): x - eine undefiniertes Objekt help(&quot;sqrt&quot;) Funktion(en): help() Objekt(e): sqrt() - ein Funktion als Objekt, hier im Charakterformat ausgeschrieben Warum erfolgt jetzt die Schreibweise von sqrt in der Art und Weise? Gehen wir dazu kurz in die Hilfefunktion selber: ?help Funktion(en): ? als andere Schreibweise von help() Objekt(e): help() - ein Funktion als Objekt, hier aber nicht im Charakterformat ausformuliert. Dort finden wir die Spezifizierung bei Topic: usually, a name or character string specifying the topic for which help is sought. A character string (enclosed in explicit single or double quotes) is always taken as naming a topic. Was heisst jetzt ein Charakter-String? Es gibt eben nicht nur numerische Daten x1 &lt;- 5 sondern auch textliche oder Charakterdaten x2 &lt;- &quot;fünf&quot; class(x1) ## [1] &quot;numeric&quot; typeof(x1) ## [1] &quot;double&quot; class(x2) ## [1] &quot;character&quot; typeof(x2) ## [1] &quot;character&quot; Warum zeigt R uns zwei verschiedene Merkmale bei x1 an? R speichert Zahlen auf eine bestimmte Art und Weise ab, nämlich normalerweise als sogennante doubles oder als Zahlen mit Nachkommastellen. Man könnte die 5 auch als Integer (also als Zahl ohne Kommata) abspeichern: x3 &lt;- 5L class(x3) ## [1] &quot;integer&quot; typeof(x3) ## [1] &quot;integer&quot; Das brauchen wir allerdings kaum im alltäglichen Umgang mit R. y &lt;- c(1, 3, 4, 5, 6, 7, NA) #und z &lt;- c(7, 8, 10, 11) Funktion(en): &lt;-, c() Objekt(e): y, z - ein Vektor; 1, 3, 4, 5, 6, 7, 7, 8, 10, 11 - jeweils numerische Objekte; NA - ein fehlender Wert Berechnen des arithmetischen Mittels: (7+ 8+ 10+ 11) / 4 ## [1] 9 sum(z) / length(z) ## [1] 9 mean(z) ## [1] 9 #Was passiert hier? mean(y) ## [1] NA mean(y, na.rm = T) ## [1] 4.333333 Hier haben wir wiederum ein Argument einer Funktion spezifiziert, um die fehlenden Werte auszuklammern. Wichtig: NA ist jetzt nicht dasselbe wie ein Charakter-Datum NA: y1 &lt;- c(1, 3, 4, 5, 6, 7, NA) y2 &lt;- c(1, 3, 4, 5, 6, 7, &quot;NA&quot;) mean(y1, na.rm = TRUE) ## [1] 4.333333 mean(y2, na.rm = TRUE) ## Warning in mean.default(y2, na.rm = TRUE): Argument ist weder numerisch noch ## boolesch: gebe NA zurück ## [1] NA und was ist jetzt mit dem Vektor y1 passiert? Wir sehen, dass Vektoren nur ein Datenformat enthalten können. Ansonsten müssten wir den Vektor als Liste speichern. Listen sind daher ein weiterer Objekttyp (mit dem wir aber nur selten arbeiten werden). is.logical(TRUE) Funktion(en): is.logical() Objekt(e): TRUE - ein logisches Datenformat Was ist TRUE? typeof(TRUE) ## [1] &quot;logical&quot; class(TRUE) ## [1] &quot;logical&quot; TRUE und FALSE Dies sind logische Daten  also Daten die angeben ob etwas wahr oder falsch ist. Wir können auch daraus einen Vektor machen: lv &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) Und was passiert wohl hierbei? TRUE + FALSE ## [1] 1 Es sind also einfach auch Werte: 1 oder 0. mean(y1, na.rm = 1) ## [1] 4.333333 Zusammenfassung Wir haben jetzt bereits drei verschiedene Datenarten kennengelernt: numerische Daten Charakterdaten logische Daten. Weiter haben wir bereits drei verschiedene Objekttypen kennengelernt: einzelne Werte Vektoren (als eine Reihe von Werten derselben Datenart) Listen (also Reihe von Werten derselben Datenart) Diese drei Objekttypen werden in der 5. Aufgabe ergänzt von den sogenannten Matrizen.   Sehen Sie sich die Hilfeseite der Funktion matrix() an. Wozu dient diese Funktion? Welche Argumente akzeptiert / benötigt sie und wozu dienen diese? Illustrieren Sie die Funktionsweise anhand von einem Beispiel. Die Funktion matrix() erlaubt es uns ein zweidimensionales Objekt aus einem Set von Werten (einem Vektoren) zu erstellen: Ein Beispiel von Vanesse Leutener: Beispiel: Bei einer kleinen Umfrage wurden 6 Befragte nach Geschlecht und der Höhe des monatlichen Einkommens befragt. Geschlecht 1 = weiblich 2 = männlich 3 = divers Monatliches Einkommen 1 = weniger als 800 CHF 2 = ab 800-1500 CHF 3 = ab 1500-3000 CHF 4 = ab 3000-6000 CHF 5 = mehr als 6000 CHF Geschlecht &lt;- c(2, 3, 1, 1, 1, 2) Einkommen &lt;- c(3, 5, 4, 1, 5, 5) #so? matrix(Geschlecht, Einkommen) ## [,1] [,2] ## [1,] 2 1 ## [2,] 3 1 ## [3,] 1 2 #so? matrix(c(Geschlecht, Einkommen)) ## [,1] ## [1,] 2 ## [2,] 3 ## [3,] 1 ## [4,] 1 ## [5,] 1 ## [6,] 2 ## [7,] 3 ## [8,] 5 ## [9,] 4 ## [10,] 1 ## [11,] 5 ## [12,] 5 #so sollte das passen: matrix(c(Geschlecht, Einkommen), nrow = 6, ncol = 2) ## [,1] [,2] ## [1,] 2 3 ## [2,] 3 5 ## [3,] 1 4 ## [4,] 1 1 ## [5,] 1 5 ## [6,] 2 5 #Warum stimmt das nicht? matrix(c(Geschlecht, Einkommen), nrow = 6, ncol = 2, byrow = T) ## [,1] [,2] ## [1,] 2 3 ## [2,] 1 1 ## [3,] 1 2 ## [4,] 3 5 ## [5,] 4 1 ## [6,] 5 5 Bei der Anordnung von Zeilen und Spalten wollen wir jeweils Fälle/Personen als Zeilen und Variablen als Spalten darstellen. Und wie könnte wir diese Matrix beschriften? LV_G &lt;- matrix(c(Geschlecht, Einkommen), nrow = 6, ncol = 2) colnames(LV_G) &lt;- c(&quot;Geschlecht&quot;, &quot;Einkommen (Kat.)&quot;) rownames(LV_G) &lt;- c(&quot;F1&quot;, &quot;F2&quot;, &quot;F3&quot;, &quot;F4&quot;, &quot;F5&quot;, &quot;F6&quot;) LV_G ## Geschlecht Einkommen (Kat.) ## F1 2 3 ## F2 3 5 ## F3 1 4 ## F4 1 1 ## F5 1 5 ## F6 2 5 Ein Beispiel von Delia Bazzigher: Eine Studie untersucht die mediale Präsenz der aktuellen Geschehnisse in Afghanistan in der deutschsprachigen Schweiz im September. Dazu werden z.B. die Tageszeitungen untersucht. Es wird eine Häufigkeitszählung in den Zeitungen Tages-Anzeiger, NZZ, Luzerner Zeitung und Blick durchgeführt. Gezählt werden die Anzahl Artikel sowie deren jeweilige Position, d.h. neutral/sachlich, negati/verurteilend oder positiv/unterstützend (die Codierung dieser Kategorien wird hier nicht erläutert). mTageszeitungen &lt;- matrix(c(7,3,0, 12,7,0, 5,3,0, 8,2,3), nrow = 3, ncol = 4, byrow = FALSE, dimnames = list(c(&quot;negativ&quot;, &quot;neutral&quot;, &quot;positiv&quot;), c(&quot;Tages-Anzeiger&quot;, &quot;NZZ&quot;, &quot;Luzerner Zeitung&quot;, &quot;Blick&quot;))) mTageszeitungen ## Tages-Anzeiger NZZ Luzerner Zeitung Blick ## negativ 7 12 5 8 ## neutral 3 7 3 2 ## positiv 0 0 0 3 Was zeigt sich hier für ein Datenformat? Das ist eigentlich bereits abstrahiert! Wir könnten diese Kombination und das erstellen einer Matrix auch mit anderen Funktionen erreichen: LV_G1 &lt;- cbind(Geschlecht, Einkommen) LV_G2 &lt;- rbind(Geschlecht, Einkommen) LV_G1 ## Geschlecht Einkommen ## [1,] 2 3 ## [2,] 3 5 ## [3,] 1 4 ## [4,] 1 1 ## [5,] 1 5 ## [6,] 2 5 LV_G2 ## [,1] [,2] [,3] [,4] [,5] [,6] ## Geschlecht 2 3 1 1 1 2 ## Einkommen 3 5 4 1 5 5 typeof(LV_G1) ## [1] &quot;double&quot; class(LV_G1) ## [1] &quot;matrix&quot; &quot;array&quot; Was ist noch ein spezifische Eigenschaft einer Matrix? Geschlecht_c &lt;- c(&quot;m&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;) LV_G3 &lt;- cbind(Geschlecht_c, Einkommen) LV_G3 ## Geschlecht_c Einkommen ## [1,] &quot;m&quot; &quot;3&quot; ## [2,] &quot;d&quot; &quot;5&quot; ## [3,] &quot;f&quot; &quot;4&quot; ## [4,] &quot;f&quot; &quot;1&quot; ## [5,] &quot;f&quot; &quot;5&quot; ## [6,] &quot;m&quot; &quot;5&quot; typeof(LV_G3) ## [1] &quot;character&quot; class(LV_G3) ## [1] &quot;matrix&quot; &quot;array&quot; Matrizen können nur ein Datenformat speichern - und wandeln daher verschiedene Datenarten in das Niedrigste um. Deshalb arbeiten wir eher mit dem Datenformat bzw. Objekttyp des sogennanten data.frames (oder in ggplot dann tybbles). Dieser Objekttyp ermöglicht ein Speichern von verschiedenen Datenarten in einem zweidimensionalen Format: LV_G4 &lt;- data.frame(Geschlecht_c) LV_G4 &lt;- cbind(LV_G4, Einkommen) LV_G4 ## Geschlecht_c Einkommen ## 1 m 3 ## 2 d 5 ## 3 f 4 ## 4 f 1 ## 5 f 5 ## 6 m 5 typeof(LV_G4) ## [1] &quot;list&quot; class(LV_G4) ## [1] &quot;data.frame&quot; Falls Sie noch Probleme bei der Installation von R bzw. RStudio oder sonstige technische Schwierigkeiten haben, können Sie sich gerne weiterhin per E-Mail melden! Neuere Versionen von RStudio bieten im Fenster der Konsole auch die Möglichkeit, sogenannte Jobs auszuführen (ein Tpp von Josias Bruderer), siehe [hier]:(https://www.youtube.com/watch?v=EBlk1kRbKeU). "],["wochenplan-03.html", "3 Wochenplan 03 3.1 Lernziele 3.2 Aufgaben", " 3 Wochenplan 03 Vorbereitung von der 03. auf die 04.Einheit. 3.1 Lernziele In der dritten Seminarwoche vertiefen wir Elemente der Programmiersprache R, die Sie bereits kennengelernt haben, und betten sie in neue Zusammenhänge ein. Vertieft wird nochmals der Umgang mit verschiedenen Datenarten und Objekttypen: Zahlen, Text und logische Werte sowie einzelne Werte, Vektoren und Matrizen. Neu wollen wir einige Möglichkeiten kennenlernen, über bestimmte Funktionen systematisch Vektoren zu definieren. Diese Grundlagen wollen wir dann nutzen, um erste statistische Inhalte bzw. Methoden einführen, nämlich die bivariaten Zusammenhänge von metrischen Variablen (Korrelation). Zusammenfassend lassen sich damit folgende Seminarziele festhalten: Sie können die drei bisher kennengelernten Objekttypen (einzelne Zahl, Vektor, und Matrix) kombinieren. Sie kennen die drei verschiedenen Datenarten von R: Sie verstehen die Rolle von numerischen Daten, Sie verstehen die Rolle von textförmigen Daten Sie verstehen die Rolle von logischen Daten. Sie können Vektoren mittels der Funktionen   seq()  sowie rep() definieren  und diese auf alle drei Arten von Daten anwenden. Sie verstehen, was eine Korrelation von zwei Variablen bedeutet und können bivariate Zusammenhänge in R berechnen und interpretieren. 3.2 Aufgaben Erstellen Sie vier verschiedene Vektoren mit je einer Länge von vier und verbinden Sie diese zu einer 4x4-Matrix. Die Funktion apply() erlaubt Ihnen, eine Funktionen wie z.B. mean() oder var() auf diese Matrix anzuwenden. Nur wie genau? Sehen Sie sich die Hilfe zu apply() an, probieren Sie die Funktion aus und versuchen Sie zu verstehen, wie sie genau funktioniert. Erläutern Sie apply() dann in eigenen Worten und mit Hilfe der von Ihnen erzeugten 4x4-Matrix! Erstellen Sie je einen Vektor mit numerischen Daten, textförmigen Daten und logischen Daten. Die Funktionen as.numeric(), as.character() und as.logical() lassen Sie eine Datenarten in eine andere zwingen bzw. als eine andere Datenart interpretieren. Wann funktioniert dies? Und wo sind die Grenzen dieses Zwingens? Definieren Sie folgende Vektoren mittels der Funktionen seq() und rep(): Vektor 3a: 1 2 3 4 5 6 7 8 9 10 Vektor 3b: 1 1 1 2 2 2 3 3 3 Vektor 3c: Die Zahlen des Vektors b als ausgeschriebene Wörter Vektor 3d: 1 4 7 10 13 Vektor 3e: 1 4 9 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 1100 14899 678999 Was macht das Argument trim für die Funktion mean()? Wozu könnten Sie dieses Argument in einem sozialwissenschaftlichen Kontext nutzen? Spezifizieren Sie das Argument auf sinnvolle Weise, um das arithmetische Mittel des in Aufgabe 3e erstellten Vektors zu berechnen! Sie sollen verschiedene Paare von Vektoren mittels der Funktionen c(), rep() und seq() definieren, die jeweils unterschiedlich korrelieren. Diese Vektoren  d.h. Variablen  und deren Korrelationen sollen sozialwissenschaftlichen Phänomenen entsprechen. Berechnen Sie jeweils den Korrelationskoeffizienten. Ein Paar von Vektoren (mit je einer Länge von rund 100) soll eine Korrelation von ca. 0.4 aufweisen. Ein Paar von Vektoren (mit je einer Länge von rund 100) soll eine sehr starke Korrelation aufweisen. Ein Paar von Vektoren (mit je einer Länge von rund 100) soll eine schwache negative Korrelation aufweisen. Bearbeiten Sie die Aufgaben wiederum in RMarkdown und knitten Sie Ihre Ergebnisse zu einem PDF-Dokument. Beschriften Sie Ihr Dokument mit FL03_NameVorname.pdf und geben das Dokument via OLAT vor der nächsten Einheit ab. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
